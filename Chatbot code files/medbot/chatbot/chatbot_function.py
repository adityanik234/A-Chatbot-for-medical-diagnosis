from chatbot.DiseaseHypothesisGenerator import *
from chatbot.symptomExtractor import *
from chatbot.QuestionGenerator import *
from chatbot.intents_classifier.intents_classifier import *
from gensim.models.fasttext import load_facebook_model
import string

# Loading the disease description data
# Contains a brief description of each disease
disease_description = pd.read_csv(r'chatbot/data/disease_description.csv', header=None)
disease_description = disease_description.set_index(disease_description[0], drop=True)

# Loading the Facebook's fasttext model file
# words = pd.read_table('chatbot/data/glove.840B.300d.txt', sep=" ", index_col=0, header=None, quoting=csv.QUOTE_NONE)
words = load_facebook_model('chatbot/data/crawl-300d-2M-subword.bin')

# Loading the training data for training the Logistic regression model
df = pd.read_csv(r'chatbot/data/Training.csv')

# Initialising the symptom corpus
# This symptom corpus is obtained from the column names of the training data
symptom_corpus = list(df.columns)
symptom_corpus = [x.replace('_', ' ') for x in symptom_corpus]
symptom_corpus = [x.translate(str.maketrans('', '', string.punctuation)) for x in symptom_corpus]
symptom_corpus = [x.translate(str.maketrans('', '', string.digits)) for x in symptom_corpus]
training_df = df
training_df.columns = symptom_corpus


# Removing the two symptoms as toxic look typhos is actually a disease and the model has issues generating embeddings for
# dischromic patches
symptom_corpus.remove('dischromic  patches')
symptom_corpus.remove('toxic look typhos')
symptom_corpus.remove('prognosis')


# Shuffling the data
training_df = training_df.sample(frac=1, random_state=1).reset_index(drop=True)
X_train = training_df.drop(['prognosis', 'dischromic  patches', 'toxic look typhos'], axis=1)
y_train = training_df['prognosis']

# Loading the embeddings for the symptom corpus
# These embeddings were generated and saved in a csv file using the fasttext model in another notebook
# Which are now being loaded directly to save time
symptom_embeddings = pd.read_csv(r'chatbot/data/new symptom corpus embeddings.csv')

# Getting the disease symptom dictionary
training = pd.read_csv(r'chatbot/data/Training.csv')
reduced_data = training.groupby(training['prognosis']).max()

symptom_corpus = list(reduced_data.columns)
symptom_corpus = [x.replace('_', ' ') for x in symptom_corpus]
symptom_corpus = [x.translate(str.maketrans('', '', string.punctuation)) for x in symptom_corpus]
symptom_corpus = [x.translate(str.maketrans('', '', string.digits)) for x in symptom_corpus]
reduced_data.columns = symptom_corpus
reduced_data = reduced_data.drop(['dischromic  patches', 'toxic look typhos'], axis=1)
symptom_corpus = reduced_data.columns

new_df = reduced_data.T
disease_dict = {}
for disease in new_df.columns:
    disease_dict[disease] = list(new_df[new_df[disease] == 1].index)

# Global variables used by the functions
random_symptom_list = []  # List that stores the symptoms about which questions have already been asked to avoid
# repetition
# Condition determines the response of the chatbot_response function
condition = 0
# Random symptom is the random symptom generated by the question generator
random_symptom = None
# Input symptoms is the one hot vector representing the presence or absence of the symptoms
input_symptoms = []
# diagnosis mode starts the diagnosis in case the intent of the users input text is 'sickpatient'
diagnosis_mode = False
# Intent is used to determine  if the user is actually asking about his medical condition or just playnin are=ound
# with it
intent = None
# not_tagged is true incase the BERN Bio_BERT model can tag any symptoms in the input text
not_tagged = False


# Loading the pretrained intent classifier
assistant = GenericAssistant('chatbot/data/chatbot_intents.json', model_name="test_model")
assistant.load_model('chatbot/intents_classifier/test_model')

# Function definition for getting the user intents based on the input
def get_user_intent(msg):
    global assistant
    response = assistant.request(msg)
    intent = assistant.current_intent
    return response, intent


# Function definition for sending the question to the web interface
def chatbot_response(msg):
    # Global variables
    global condition, diseases, diagnosis_mode, intent, not_tagged
    global input_symptoms, random_symptom
    global random_symptom_list

    response, intent = get_user_intent(msg)
    # If the intent is detected as sick patient the diagnosis mode is on
    # The chatbot then starts asking questions about the disease
    if intent == 'sickpatient':
        diagnosis_mode = True
    else:
        pass

    if diagnosis_mode:

        if condition == 0:
            condition = 1
            return response + ' Could you please give me a brief description of your symptoms?'

        elif condition == 1:
            if not_tagged == False:
                input_symptoms = posSymptomExtraction(msg, symptom_corpus, symptom_embeddings, words)
                diseases, input_vector, probs = diseaseHypothesis(input_symptoms, symptom_corpus, X_train, y_train,
                                                                  words)
                question = questionGenerator1(diseases, input_symptoms, disease_dict,
                                              random_symptom_list, words)
            else:
                input_symptoms.append(msg)
                sim = -100
                best = None
                for i in range(len(input_symptoms)):
                    emb = fasttextEmbeddings(input_symptoms[i], words)
                    for symptom in symptom_corpus:
                        emb1 = fasttextEmbeddings(symptom, words)
                        sim1 = similarityCheck(emb, emb1)
                        if sim1 > sim:
                            sim = sim1
                            best = symptom
                    input_symptoms[i] = best

                diseases, input_vector, probs = diseaseHypothesis(input_symptoms, symptom_corpus, X_train, y_train,
                                                                  words)
                question = questionGenerator1(diseases, input_symptoms, disease_dict,
                                              random_symptom_list, words)
                not_tagged = False

            # In case the BERN model does not detect any symptom words in the input text
            if len(input_symptoms) == 0:
                not_tagged = True
                return "I'm sorry I didn't quite get that could you please enter one specific symptom for now? "

            else:
                condition = 2
                print('Input symptoms ', input_symptoms)
                print(diseases)
                print(probs)
                return question

        else:
            try:
                input_symptoms, random_symptom_list = questionGenerator2(msg, input_symptoms, random_symptom_list,
                                                                         words)

                diseases, input_vector, probs = diseaseHypothesis(input_symptoms, symptom_corpus, X_train, y_train,
                                                                  words)

                question = questionGenerator1(diseases, input_symptoms, disease_dict,
                                              random_symptom_list, words)
                print('Input symptoms ', input_symptoms)
                print(diseases)
                print(probs)

                if probs[0][-1] > 0.90:
                    random_symptom_list = []
                    condition = 0
                    random_symptom = None
                    input_symptoms = []
                    diagnosis_mode = False
                    intent = None

                    return '***This chatbot is in its development stage and we recommend that you see a doctor***' + 'It is very likely that you have ' + str(
                        diseases[-1]) + ' . ' + str(
                        disease_description.loc[diseases[-1]][1])
                else:
                    pass

                return question

            except IndexError:
                # The IndexError normally occurs when the questions about all the symptoms of the 4 most likely
                # diseases have been asked
                # This outputs the most likely disease based on the highest probability of occurrence
                # Reinitialise the global variables to its default values
                condition = False
                random_symptom_list = []
                condition = 0
                random_symptom = None
                input_symptoms = []
                diagnosis_mode = False

                try:
                    return '***This chatbot is in its development stage and we recommend that you see a doctor***' + 'There may be a slight chance of you having  ' + str(
                        diseases[-1]) + ' . ' + str(
                        disease_description.loc[diseases[-1]][1])
                except:
                    return '***This chatbot is in its development stage and we recommend that you see a doctor***' + 'There may be a slight chance of you having  ' + str(
                        diseases[-1]) + ' . '

            except:
                return " Im sorry could you please repeat that a bit more clearly"

    else:
        return response
